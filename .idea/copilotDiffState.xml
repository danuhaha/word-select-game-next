<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/components/Buttons.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/Buttons.tsx" />
              <option name="originalContent" value="'use client';&#10;&#10;import React, { useState, useEffect } from 'react';&#10;import Timer from './Timer'; // Import Timer component&#10;&#10;interface ButtonsProps {&#10;  jumbledWord: string[];&#10;  setSelectedHandler: (index: number) =&gt; void;&#10;  clearError: () =&gt; void;&#10;  clearSelectedHandler: () =&gt; void;&#10;  submitHandler: () =&gt; void;&#10;  backspaceHandler: () =&gt; void; // Add backspace handler&#10;  letterCounts: Record&lt;string, number&gt;;&#10;  shuffleHandler?: () =&gt; void; // Optional shuffle handler&#10;  resetTrigger?: number; // New prop to trigger reset&#10;  selectedIndices?: number[]; // Add this to sync button states&#10;  selectedLettersCount: number; // Add prop to track selected letters count&#10;  gameStarted?: boolean; // New prop to control game state&#10;  onStartGame?: () =&gt; void; // Callback for starting the game&#10;  onTimerEnd: () =&gt; void; // Callback for when the timer ends&#10;}&#10;&#10;const Buttons: React.FC&lt;ButtonsProps&gt; = ({&#10;  jumbledWord,&#10;  setSelectedHandler,&#10;  clearError,&#10;  clearSelectedHandler,&#10;  submitHandler,&#10;  backspaceHandler,&#10;  letterCounts,&#10;  resetTrigger,&#10;  selectedIndices = [],&#10;  selectedLettersCount,&#10;  gameStarted = true,&#10;  onStartGame,&#10;  onTimerEnd,&#10;}) =&gt; {&#10;  const [selectedLetters, setSelectedLetters] = useState&lt;Set&lt;number&gt;&gt;(new Set());&#10;  const [usedLetterCounts, setUsedLetterCounts] = useState&lt;Record&lt;string, number&gt;&gt;({});&#10;  const [timerEnded, setTimerEnded] = useState(false);&#10;&#10;  useEffect(() =&gt; {&#10;    // Initialize letter counts&#10;    const initialUsedCounts: Record&lt;string, number&gt; = {};&#10;&#10;    jumbledWord.forEach((letter) =&gt; {&#10;      initialUsedCounts[letter] = 0;&#10;    });&#10;&#10;    setUsedLetterCounts(initialUsedCounts);&#10;    setSelectedLetters(new Set());&#10;  }, [jumbledWord]);&#10;&#10;  // Sync with parent component's selectedIndices&#10;  useEffect(() =&gt; {&#10;    setSelectedLetters(new Set(selectedIndices));&#10;&#10;    // Recalculate used letter counts based on selected indices&#10;    const newUsedCounts: Record&lt;string, number&gt; = {};&#10;    jumbledWord.forEach((letter) =&gt; {&#10;      newUsedCounts[letter] = 0;&#10;    });&#10;&#10;    selectedIndices.forEach((index) =&gt; {&#10;      if (index &lt; jumbledWord.length) {&#10;        const letter = jumbledWord[index];&#10;        newUsedCounts[letter] = (newUsedCounts[letter] || 0) + 1;&#10;      }&#10;    });&#10;&#10;    setUsedLetterCounts(newUsedCounts);&#10;  }, [selectedIndices, jumbledWord]);&#10;&#10;  // Reset button states when resetTrigger changes&#10;  useEffect(() =&gt; {&#10;    if (resetTrigger !== undefined) {&#10;      setSelectedLetters(new Set());&#10;      const resetCounts: Record&lt;string, number&gt; = {};&#10;      jumbledWord.forEach((letter) =&gt; {&#10;        resetCounts[letter] = 0;&#10;      });&#10;      setUsedLetterCounts(resetCounts);&#10;    }&#10;  }, [resetTrigger, jumbledWord]);&#10;&#10;  const onLetterClick = (letter: string, index: number) =&gt; {&#10;    if (selectedLetters.has(index)) {&#10;      return;&#10;    }&#10;    if (usedLetterCounts[letter] &lt; letterCounts[letter]) {&#10;      setUsedLetterCounts((prev) =&gt; ({&#10;        ...prev,&#10;        [letter]: prev[letter] + 1,&#10;      }));&#10;      setSelectedLetters((prev) =&gt; {&#10;        const updated = new Set(prev);&#10;        updated.add(index);&#10;        return updated;&#10;      });&#10;      setSelectedHandler(index); // Pass the index, not the letter&#10;      clearError();&#10;    }&#10;  };&#10;&#10;  const onClearHandler = () =&gt; {&#10;    setSelectedLetters(new Set());&#10;    setUsedLetterCounts(Object.fromEntries(Object.keys(usedLetterCounts).map((key) =&gt; [key, 0])));&#10;    clearSelectedHandler();&#10;  };&#10;&#10;  // Handler for timer end&#10;  const handleTimerEnd = () =&gt; {&#10;    setTimerEnded(true);&#10;    if (onTimerEnd) onTimerEnd();&#10;  };&#10;&#10;  // Button rendering logic moved outside JSX to fix ESLint error&#10;  const isTouchDevice = typeof window !== 'undefined' &amp;&amp; ('ontouchstart' in window || navigator.maxTouchPoints &gt; 0);&#10;  const startButton = (&#10;    &lt;button&#10;      {...(isTouchDevice&#10;        ? {&#10;            onTouchStart: (e) =&gt; {&#10;              e.preventDefault();&#10;              if (onStartGame) onStartGame();&#10;            },&#10;          }&#10;        : {&#10;            onClick: () =&gt; {&#10;              if (onStartGame) onStartGame();&#10;            },&#10;          })}&#10;      className='rounded-full border border-primary px-4 py-3 text-xs font-medium xxs:text-sm xs:text-base'&#10;    &gt;&#10;      Играть&#10;    &lt;/button&gt;&#10;  );&#10;&#10;  return (&#10;    &lt;div className=''&gt;&#10;      &lt;div className={`mb-4 flex max-w-full flex-wrap justify-center gap-0.5 sm:gap-1 ${!gameStarted ? 'blur-sm filter' : ''}`}&gt;&#10;        {jumbledWord.map((letter, index) =&gt; {&#10;          // Simple device detection&#10;          const isTouchDevice = typeof window !== 'undefined' &amp;&amp; ('ontouchstart' in window || navigator.maxTouchPoints &gt; 0);&#10;          return (&#10;            &lt;button&#10;              key={index}&#10;              {...(isTouchDevice&#10;                ? {&#10;                    onTouchStart: (e) =&gt; {&#10;                      e.preventDefault();&#10;                      onLetterClick(letter, index);&#10;                    },&#10;                  }&#10;                : { onClick: () =&gt; onLetterClick(letter, index) })}&#10;              disabled={selectedLetters.has(index) || !gameStarted}&#10;              className={`h-8 w-8 cursor-pointer rounded text-sm font-bold transition-all sm:h-8 sm:w-8 sm:text-sm md:h-10 md:w-10 md:text-base ${&#10;                selectedLetters.has(index) ? 'cursor-not-allowed bg-cell-selected text-celltext-selected' : 'bg-cell-deselected text-celltext-deselected'&#10;              }`}&#10;            &gt;&#10;              {letter.toUpperCase()}&#10;            &lt;/button&gt;&#10;          );&#10;        })}&#10;      &lt;/div&gt;&#10;&#10;      &lt;div className={`mb-4 flex items-center justify-center ${!gameStarted ? 'invisible' : ''}`}&gt;&#10;        &lt;Timer&#10;          seconds={5000} // 7 minutes in milliseconds&#10;          setTimeHandler={() =&gt; {}} // Placeholder handler&#10;          onTimerEndHandler={handleTimerEnd} // Use local handler&#10;          shouldStart={gameStarted &amp;&amp; !timerEnded}&#10;        /&gt;&#10;      &lt;/div&gt;&#10;&#10;      &lt;div className='flex flex-wrap justify-center gap-2'&gt;&#10;        {timerEnded ? (&#10;          &lt;button&#10;            onClick={() =&gt; window.location.reload()}&#10;            className='rounded-full border border-primary px-4 py-3 text-xs font-medium xxs:text-sm xs:text-base'&#10;          &gt;&#10;            Играть снова&#10;          &lt;/button&gt;&#10;        ) : !gameStarted ? (&#10;          startButton&#10;        ) : (&#10;          &lt;&gt;&#10;            {(() =&gt; {&#10;              const isTouchDevice = typeof window !== 'undefined' &amp;&amp; ('ontouchstart' in window || navigator.maxTouchPoints &gt; 0);&#10;              return (&#10;                &lt;button&#10;                  {...(isTouchDevice&#10;                    ? {&#10;                        onTouchStart: (e) =&gt; {&#10;                          e.preventDefault();&#10;                          onClearHandler();&#10;                        },&#10;                      }&#10;                    : { onClick: () =&gt; onClearHandler() })}&#10;                  disabled={selectedLettersCount === 0}&#10;                  className={`rounded-full border px-4 py-3 text-xs font-medium xxs:text-sm xs:text-base ${&#10;                    selectedLettersCount === 0 ? 'cursor-not-allowed border-secondary text-secondary' : 'cursor-pointer border-primary text-primary'&#10;                  }`}&#10;                &gt;&#10;                  Очистить&#10;                &lt;/button&gt;&#10;              );&#10;            })()}&#10;            {(() =&gt; {&#10;              const isTouchDevice = typeof window !== 'undefined' &amp;&amp; ('ontouchstart' in window || navigator.maxTouchPoints &gt; 0);&#10;              return (&#10;                &lt;button&#10;                  {...(isTouchDevice&#10;                    ? {&#10;                        onTouchStart: (e) =&gt; {&#10;                          e.preventDefault();&#10;                          backspaceHandler();&#10;                        },&#10;                      }&#10;                    : { onClick: () =&gt; backspaceHandler() })}&#10;                  disabled={selectedLettersCount === 0}&#10;                  className={`rounded-full border px-4 py-3 text-xs font-medium xxs:text-sm xs:text-base ${&#10;                    selectedLettersCount === 0 ? 'cursor-not-allowed border-secondary text-secondary' : 'cursor-pointer border-primary text-primary'&#10;                  }`}&#10;                &gt;&#10;                  Стереть&#10;                &lt;/button&gt;&#10;              );&#10;            })()}&#10;            {(() =&gt; {&#10;              const isTouchDevice = typeof window !== 'undefined' &amp;&amp; ('ontouchstart' in window || navigator.maxTouchPoints &gt; 0);&#10;              return (&#10;                &lt;button&#10;                  {...(isTouchDevice&#10;                    ? {&#10;                        onTouchStart: (e) =&gt; {&#10;                          e.preventDefault();&#10;                          submitHandler();&#10;                        },&#10;                      }&#10;                    : { onClick: () =&gt; submitHandler() })}&#10;                  disabled={selectedLettersCount &lt; 4}&#10;                  className={`rounded-full border px-4 py-3 text-xs font-medium xxs:text-sm xs:text-base ${&#10;                    selectedLettersCount &lt; 4&#10;                      ? 'cursor-not-allowed border-maincolormuted bg-background text-maincolormuted'&#10;                      : 'cursor-pointer border-maincolor bg-maincolor text-lettertext'&#10;                  }`}&#10;                &gt;&#10;                  Отправить&#10;                &lt;/button&gt;&#10;              );&#10;            })()}&#10;          &lt;/&gt;&#10;        )}&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;};&#10;&#10;export default Buttons;&#10;" />
              <option name="updatedContent" value="'use client';&#10;&#10;import React, { useState, useEffect } from 'react';&#10;import Timer from './Timer'; // Import Timer component&#10;&#10;interface ButtonsProps {&#10;  jumbledWord: string[];&#10;  setSelectedHandler: (index: number) =&gt; void;&#10;  clearError: () =&gt; void;&#10;  clearSelectedHandler: () =&gt; void;&#10;  submitHandler: () =&gt; void;&#10;  backspaceHandler: () =&gt; void; // Add backspace handler&#10;  letterCounts: Record&lt;string, number&gt;;&#10;  shuffleHandler?: () =&gt; void; // Optional shuffle handler&#10;  resetTrigger?: number; // New prop to trigger reset&#10;  selectedIndices?: number[]; // Add this to sync button states&#10;  selectedLettersCount: number; // Add prop to track selected letters count&#10;  gameStarted?: boolean; // New prop to control game state&#10;  onStartGame?: () =&gt; void; // Callback for starting the game&#10;  onTimerEnd: () =&gt; void; // Callback for when the timer ends&#10;}&#10;&#10;const Buttons: React.FC&lt;ButtonsProps&gt; = ({&#10;  jumbledWord,&#10;  setSelectedHandler,&#10;  clearError,&#10;  clearSelectedHandler,&#10;  submitHandler,&#10;  backspaceHandler,&#10;  letterCounts,&#10;  resetTrigger,&#10;  selectedIndices = [],&#10;  selectedLettersCount,&#10;  gameStarted = true,&#10;  onStartGame,&#10;  onTimerEnd,&#10;}) =&gt; {&#10;  const [selectedLetters, setSelectedLetters] = useState&lt;Set&lt;number&gt;&gt;(new Set());&#10;  const [usedLetterCounts, setUsedLetterCounts] = useState&lt;Record&lt;string, number&gt;&gt;({});&#10;  const [timerEnded, setTimerEnded] = useState(false);&#10;&#10;  useEffect(() =&gt; {&#10;    // Initialize letter counts&#10;    const initialUsedCounts: Record&lt;string, number&gt; = {};&#10;&#10;    jumbledWord.forEach((letter) =&gt; {&#10;      initialUsedCounts[letter] = 0;&#10;    });&#10;&#10;    setUsedLetterCounts(initialUsedCounts);&#10;    setSelectedLetters(new Set());&#10;  }, [jumbledWord]);&#10;&#10;  // Sync with parent component's selectedIndices&#10;  useEffect(() =&gt; {&#10;    setSelectedLetters(new Set(selectedIndices));&#10;&#10;    // Recalculate used letter counts based on selected indices&#10;    const newUsedCounts: Record&lt;string, number&gt; = {};&#10;    jumbledWord.forEach((letter) =&gt; {&#10;      newUsedCounts[letter] = 0;&#10;    });&#10;&#10;    selectedIndices.forEach((index) =&gt; {&#10;      if (index &lt; jumbledWord.length) {&#10;        const letter = jumbledWord[index];&#10;        newUsedCounts[letter] = (newUsedCounts[letter] || 0) + 1;&#10;      }&#10;    });&#10;&#10;    setUsedLetterCounts(newUsedCounts);&#10;  }, [selectedIndices, jumbledWord]);&#10;&#10;  // Reset button states when resetTrigger changes&#10;  useEffect(() =&gt; {&#10;    if (resetTrigger !== undefined) {&#10;      setSelectedLetters(new Set());&#10;      const resetCounts: Record&lt;string, number&gt; = {};&#10;      jumbledWord.forEach((letter) =&gt; {&#10;        resetCounts[letter] = 0;&#10;      });&#10;      setUsedLetterCounts(resetCounts);&#10;    }&#10;  }, [resetTrigger, jumbledWord]);&#10;&#10;  const onLetterClick = (letter: string, index: number) =&gt; {&#10;    if (selectedLetters.has(index)) {&#10;      return;&#10;    }&#10;    if (usedLetterCounts[letter] &lt; letterCounts[letter]) {&#10;      setUsedLetterCounts((prev) =&gt; ({&#10;        ...prev,&#10;        [letter]: prev[letter] + 1,&#10;      }));&#10;      setSelectedLetters((prev) =&gt; {&#10;        const updated = new Set(prev);&#10;        updated.add(index);&#10;        return updated;&#10;      });&#10;      setSelectedHandler(index); // Pass the index, not the letter&#10;      clearError();&#10;    }&#10;  };&#10;&#10;  const onClearHandler = () =&gt; {&#10;    setSelectedLetters(new Set());&#10;    setUsedLetterCounts(Object.fromEntries(Object.keys(usedLetterCounts).map((key) =&gt; [key, 0])));&#10;    clearSelectedHandler();&#10;  };&#10;&#10;  // Handler for timer end&#10;  const handleTimerEnd = () =&gt; {&#10;    setTimerEnded(true);&#10;    if (onTimerEnd) onTimerEnd();&#10;  };&#10;&#10;  // Button rendering logic moved outside JSX to fix ESLint error&#10;  const isTouchDevice = typeof window !== 'undefined' &amp;&amp; ('ontouchstart' in window || navigator.maxTouchPoints &gt; 0);&#10;  const startButton = (&#10;    &lt;button&#10;      {...(isTouchDevice&#10;        ? {&#10;            onTouchStart: (e) =&gt; {&#10;              e.preventDefault();&#10;              if (onStartGame) onStartGame();&#10;            },&#10;          }&#10;        : {&#10;            onClick: () =&gt; {&#10;              if (onStartGame) onStartGame();&#10;            },&#10;          })}&#10;      className='rounded-full border border-primary px-4 py-3 text-xs font-medium xxs:text-sm xs:text-base'&#10;    &gt;&#10;      Играть&#10;    &lt;/button&gt;&#10;  );&#10;&#10;  return (&#10;    &lt;div className=''&gt;&#10;      &lt;div className={`mb-4 flex max-w-full flex-wrap justify-center gap-0.5 sm:gap-1 ${!gameStarted ? 'blur-sm filter' : ''}`}&gt;&#10;        {jumbledWord.map((letter, index) =&gt; {&#10;          // Simple device detection&#10;          const isTouchDevice = typeof window !== 'undefined' &amp;&amp; ('ontouchstart' in window || navigator.maxTouchPoints &gt; 0);&#10;          return (&#10;            &lt;button&#10;              key={index}&#10;              {...(isTouchDevice&#10;                ? {&#10;                    onTouchStart: (e) =&gt; {&#10;                      e.preventDefault();&#10;                      onLetterClick(letter, index);&#10;                    },&#10;                  }&#10;                : { onClick: () =&gt; onLetterClick(letter, index) })}&#10;              disabled={selectedLetters.has(index) || !gameStarted}&#10;              className={`h-8 w-8 cursor-pointer rounded text-sm font-bold transition-all sm:h-8 sm:w-8 sm:text-sm md:h-10 md:w-10 md:text-base ${&#10;                selectedLetters.has(index) ? 'cursor-not-allowed bg-cell-selected text-celltext-selected' : 'bg-cell-deselected text-celltext-deselected'&#10;              }`}&#10;            &gt;&#10;              {letter.toUpperCase()}&#10;            &lt;/button&gt;&#10;          );&#10;        })}&#10;      &lt;/div&gt;&#10;&#10;      &lt;div className={`mb-4 flex items-center justify-center ${!gameStarted ? 'invisible' : ''}`}&gt;&#10;        &lt;Timer&#10;          seconds={5000} // 7 minutes in milliseconds&#10;          setTimeHandler={() =&gt; {}} // Placeholder handler&#10;          onTimerEndHandler={handleTimerEnd} // Use local handler&#10;          shouldStart={gameStarted &amp;&amp; !timerEnded}&#10;        /&gt;&#10;      &lt;/div&gt;&#10;&#10;      &lt;div className='flex flex-wrap justify-center gap-2'&gt;&#10;        {timerEnded ? (&#10;          &lt;button&#10;            onClick={() =&gt; window.location.reload()}&#10;            className='rounded-full border border-primary px-4 py-3 text-xs font-medium xxs:text-sm xs:text-base'&#10;          &gt;&#10;            Играть снова&#10;          &lt;/button&gt;&#10;        ) : !gameStarted ? (&#10;          startButton&#10;        ) : (&#10;          &lt;&gt;&#10;            {(() =&gt; {&#10;              const isTouchDevice = typeof window !== 'undefined' &amp;&amp; ('ontouchstart' in window || navigator.maxTouchPoints &gt; 0);&#10;              return (&#10;                &lt;button&#10;                  {...(isTouchDevice&#10;                    ? {&#10;                        onTouchStart: (e) =&gt; {&#10;                          e.preventDefault();&#10;                          onClearHandler();&#10;                        },&#10;                      }&#10;                    : { onClick: () =&gt; onClearHandler() })}&#10;                  disabled={selectedLettersCount === 0}&#10;                  className={`rounded-full border px-4 py-3 text-xs font-medium xxs:text-sm xs:text-base ${&#10;                    selectedLettersCount === 0 ? 'cursor-not-allowed border-secondary text-secondary' : 'cursor-pointer border-primary text-primary'&#10;                  }`}&#10;                &gt;&#10;                  Очистить&#10;                &lt;/button&gt;&#10;              );&#10;            })()}&#10;            {(() =&gt; {&#10;              const isTouchDevice = typeof window !== 'undefined' &amp;&amp; ('ontouchstart' in window || navigator.maxTouchPoints &gt; 0);&#10;              return (&#10;                &lt;button&#10;                  {...(isTouchDevice&#10;                    ? {&#10;                        onTouchStart: (e) =&gt; {&#10;                          e.preventDefault();&#10;                          backspaceHandler();&#10;                        },&#10;                      }&#10;                    : { onClick: () =&gt; backspaceHandler() })}&#10;                  disabled={selectedLettersCount === 0}&#10;                  className={`rounded-full border px-4 py-3 text-xs font-medium xxs:text-sm xs:text-base ${&#10;                    selectedLettersCount === 0 ? 'cursor-not-allowed border-secondary text-secondary' : 'cursor-pointer border-primary text-primary'&#10;                  }`}&#10;                &gt;&#10;                  Стереть&#10;                &lt;/button&gt;&#10;              );&#10;            })()}&#10;            {(() =&gt; {&#10;              const isTouchDevice = typeof window !== 'undefined' &amp;&amp; ('ontouchstart' in window || navigator.maxTouchPoints &gt; 0);&#10;              return (&#10;                &lt;button&#10;                  {...(isTouchDevice&#10;                    ? {&#10;                        onTouchStart: (e) =&gt; {&#10;                          e.preventDefault();&#10;                          submitHandler();&#10;                        },&#10;                      }&#10;                    : { onClick: () =&gt; submitHandler() })}&#10;                  disabled={selectedLettersCount &lt; 4}&#10;                  className={`rounded-full border px-4 py-3 text-xs font-medium xxs:text-sm xs:text-base ${&#10;                    selectedLettersCount &lt; 4&#10;                      ? 'cursor-not-allowed border-maincolormuted bg-background text-maincolormuted'&#10;                      : 'cursor-pointer border-maincolor bg-maincolor text-lettertext'&#10;                  }`}&#10;                &gt;&#10;                  Отправить&#10;                &lt;/button&gt;&#10;              );&#10;            })()}&#10;          &lt;/&gt;&#10;        )}&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;};&#10;&#10;export default Buttons;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/PlayAgainButton.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/PlayAgainButton.tsx" />
              <option name="updatedContent" value="import React from 'react';&#10;&#10;const PlayAgainButton: React.FC = () =&gt; (&#10;  &lt;button&#10;    onClick={() =&gt; window.location.reload()}&#10;    className='rounded-full border border-primary px-4 py-3 text-xs font-medium xxs:text-sm xs:text-base'&#10;  &gt;&#10;    Играть снова&#10;  &lt;/button&gt;&#10;);&#10;&#10;export default PlayAgainButton;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/PlayButton.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/PlayButton.tsx" />
              <option name="updatedContent" value="import React from 'react';&#10;&#10;interface PlayButtonProps {&#10;  onStart: () =&gt; void;&#10;}&#10;&#10;const PlayButton: React.FC&lt;PlayButtonProps&gt; = ({ onStart }) =&gt; (&#10;  &lt;button&#10;    onClick={onStart}&#10;    className='rounded-full border border-primary px-4 py-3 text-xs font-medium xxs:text-sm xs:text-base'&#10;  &gt;&#10;    Играть&#10;  &lt;/button&gt;&#10;);&#10;&#10;export default PlayButton;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/RankSystem.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/RankSystem.tsx" />
              <option name="originalContent" value="'use client';&#10;&#10;import React from 'react';&#10;&#10;interface RankSystemProps {&#10;  score: number;&#10;  maxPossibleScore: number;&#10;}&#10;&#10;const RankSystem: React.FC&lt;RankSystemProps&gt; = ({ score }) =&gt; {&#10;  const ranks = [&#10;    { name: 'Новичок', minPoints: 0 },&#10;    { name: 'Хорошее начало', minPoints: 4 },&#10;    { name: 'Разогрев', minPoints: 10 },&#10;    { name: 'Неплохо', minPoints: 16 },&#10;    { name: 'Хорошо', minPoints: 30 },&#10;    { name: 'Отлично', minPoints: 50 },&#10;    { name: 'Мастер', minPoints: 80 },&#10;    { name: 'Профи', minPoints: 100 },&#10;    { name: 'Гений', minPoints: 140 },&#10;    { name: 'Сверхразум', minPoints: 200 },&#10;  ];&#10;&#10;  // Find current rank based on score&#10;  const currentRank = [...ranks].reverse().find((rank) =&gt; score &gt;= rank.minPoints) || ranks[0];&#10;&#10;  // Calculate the position of the current rank circle (as percentage of total width)&#10;  const currentRankIndex = ranks.findIndex((rank) =&gt; rank.name === currentRank.name);&#10;  const progressLineWidth = currentRankIndex === 0 ? 0 : (currentRankIndex / (ranks.length - 1)) * 100;&#10;&#10;  return (&#10;    &lt;div className='flex items-center'&gt;&#10;      {/* Current rank name on the left */}&#10;      &lt;div className='flex-shrink-0'&gt;&#10;        &lt;h2 className='text-red ml-2 mr-2 text-lg font-bold sm:text-xl'&gt;{currentRank.name}&lt;/h2&gt;&#10;      &lt;/div&gt;&#10;&#10;      {/* Progress line with circular markings */}&#10;      &lt;div className='relative mr-2 flex-1'&gt;&#10;        {/* Background line */}&#10;        &lt;div className='absolute left-0 right-0 top-1/2 h-px -translate-y-1/2 transform rounded-full bg-secondary' /&gt;&#10;&#10;        {/* Progress fill */}&#10;        &lt;div&#10;          className='absolute left-0 top-1/2 h-px -translate-y-1/2 transform rounded-full bg-maincolor transition-all duration-500 ease-out'&#10;          style={{ width: `${progressLineWidth}%` }}&#10;        /&gt;&#10;&#10;        {/* Circular markings for each rank */}&#10;        &lt;div className='relative flex h-6 items-center justify-between'&gt;&#10;          {ranks.map((rank, index) =&gt; {&#10;            const isAchieved = score &gt;= rank.minPoints;&#10;            const isCurrent = rank.name === currentRank.name;&#10;&#10;            return (&#10;              &lt;div&#10;                key={rank.name}&#10;                className='group relative flex flex-col items-center'&#10;                style={{ left: index === 0 ? '0' : index === ranks.length - 1 ? 'auto' : 'auto' }}&#10;              &gt;&#10;                &lt;div&#10;                  className={`flex h-2 w-2 items-center justify-center rounded-full border-2 bg-cell-deselected transition-all duration-300 ${&#10;                    isAchieved ? 'border-maincolor bg-maincolor' : 'border-secondary bg-secondary'&#10;                  } ${isCurrent ? 'h-7 w-7' : ''}`}&#10;                &gt;&#10;                  {isCurrent &amp;&amp; &lt;span className='text-xs font-bold text-lettertext'&gt;{score}&lt;/span&gt;}&#10;                &lt;/div&gt;&#10;              &lt;/div&gt;&#10;            );&#10;          })}&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;};&#10;&#10;export default RankSystem;&#10;" />
              <option name="updatedContent" value="'use client';&#10;&#10;import React from 'react';&#10;&#10;interface RankSystemProps {&#10;  score: number;&#10;  maxPossibleScore: number;&#10;}&#10;&#10;const RankSystem: React.FC&lt;RankSystemProps&gt; = ({ score }) =&gt; {&#10;  const ranks = [&#10;    { name: 'Новичок', minPoints: 0 },&#10;    { name: 'Хорошее начало', minPoints: 4 },&#10;    { name: 'Разогрев', minPoints: 10 },&#10;    { name: 'Неплохо', minPoints: 16 },&#10;    { name: 'Хорошо', minPoints: 30 },&#10;    { name: 'Отлично', minPoints: 50 },&#10;    { name: 'Мастер', minPoints: 80 },&#10;    { name: 'Профи', minPoints: 100 },&#10;    { name: 'Гений', minPoints: 140 },&#10;    { name: 'Сверхразум', minPoints: 200 },&#10;  ];&#10;&#10;  // Find current rank based on score&#10;  const currentRank = [...ranks].reverse().find((rank) =&gt; score &gt;= rank.minPoints) || ranks[0];&#10;&#10;  // Calculate the position of the current rank circle (as percentage of total width)&#10;  const currentRankIndex = ranks.findIndex((rank) =&gt; rank.name === currentRank.name);&#10;  const progressLineWidth = currentRankIndex === 0 ? 0 : (currentRankIndex / (ranks.length - 1)) * 100;&#10;&#10;  return (&#10;    &lt;div className='flex items-center'&gt;&#10;      {/* Current rank name on the left */}&#10;      &lt;div className='flex-shrink-0'&gt;&#10;        &lt;h2 className='text-red ml-2 mr-2 text-lg font-bold sm:text-xl'&gt;{currentRank.name}&lt;/h2&gt;&#10;      &lt;/div&gt;&#10;&#10;      {/* Progress line with circular markings */}&#10;      &lt;div className='relative mr-2 flex-1'&gt;&#10;        {/* Background line */}&#10;        &lt;div className='absolute left-0 right-0 top-1/2 h-px -translate-y-1/2 transform rounded-full bg-secondary' /&gt;&#10;&#10;        {/* Progress fill */}&#10;        &lt;div&#10;          className='absolute left-0 top-1/2 h-px -translate-y-1/2 transform rounded-full bg-maincolor transition-all duration-500 ease-out'&#10;          style={{ width: `${progressLineWidth}%` }}&#10;        /&gt;&#10;&#10;        {/* Circular markings for each rank */}&#10;        &lt;div className='relative flex h-6 items-center justify-between'&gt;&#10;          {ranks.map((rank, index) =&gt; {&#10;            const isAchieved = score &gt;= rank.minPoints;&#10;            const isCurrent = rank.name === currentRank.name;&#10;&#10;            return (&#10;              &lt;div&#10;                key={rank.name}&#10;                className='group relative flex flex-col items-center'&#10;                style={{ left: index === 0 ? '0' : index === ranks.length - 1 ? 'auto' : 'auto' }}&#10;              &gt;&#10;                &lt;div&#10;                  className={`flex h-2 w-2 items-center justify-center rounded-full border-2 bg-cell-deselected transition-all duration-300 ${&#10;                    isAchieved ? 'border-maincolor bg-maincolor' : 'border-secondary bg-secondary'&#10;                  } ${isCurrent ? 'h-7 w-7' : ''}`}&#10;                &gt;&#10;                  {isCurrent &amp;&amp; &lt;span className='text-xs font-bold text-lettertext'&gt;{score}&lt;/span&gt;}&#10;                &lt;/div&gt;&#10;              &lt;/div&gt;&#10;            );&#10;          })}&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;};&#10;&#10;export default RankSystem;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/Timer.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/Timer.tsx" />
              <option name="originalContent" value="'use client';&#10;import React, { useState, useEffect, useRef, useCallback } from 'react';&#10;&#10;interface TimerProps {&#10;  seconds: number;&#10;  setTimeHandler: (data: { total: number }) =&gt; void;&#10;  onTimerEndHandler: () =&gt; void;&#10;  shouldStart?: boolean; // New prop to control when timer starts&#10;}&#10;&#10;const Timer: React.FC&lt;TimerProps&gt; = ({ seconds, setTimeHandler, onTimerEndHandler, shouldStart = true }) =&gt; {&#10;  const [timeLeft, setTimeLeft] = useState(seconds);&#10;  const [, setIsRunning] = useState(false); // Start as false&#10;  const intervalRef = useRef&lt;NodeJS.Timeout | null&gt;(null);&#10;  const lastTickRef = useRef&lt;number&gt;(Date.now());&#10;&#10;  const formatTime = useCallback((milliseconds: number) =&gt; {&#10;    const totalSeconds = Math.floor(milliseconds / 1000);&#10;    const minutes = Math.floor(totalSeconds / 60);&#10;    const seconds = totalSeconds % 60;&#10;    return {&#10;      minutes: minutes &lt; 10 ? `0${minutes}` : minutes.toString(),&#10;      seconds: seconds &lt; 10 ? `0${seconds}` : seconds.toString(),&#10;    };&#10;  }, []);&#10;&#10;  const tick = useCallback(() =&gt; {&#10;    setTimeLeft((prev) =&gt; {&#10;      const newTime = Math.max(0, prev - 1000);&#10;      setTimeHandler({ total: newTime });&#10;&#10;      if (newTime &lt;= 0) {&#10;        onTimerEndHandler();&#10;        return 0;&#10;      }&#10;&#10;&#10;      if (newTime &lt;= 0) {&#10;  }, [setTimeHandler, onTimerEndHandler]);&#10;&#10;  const startTimer = useCallback(() =&gt; {&#10;    if (intervalRef.current) return;&#10;&#10;    intervalRef.current = setInterval(tick, 1000);&#10;    lastTickRef.current = Date.now();&#10;  }, [tick]);&#10;&#10;  const stopTimer = useCallback(() =&gt; {&#10;    if (intervalRef.current) {&#10;      clearInterval(intervalRef.current);&#10;      intervalRef.current = null;&#10;    }&#10;  }, []);&#10;&#10;  // Handle visibility change&#10;  useEffect(() =&gt; {&#10;    const handleVisibilityChange = () =&gt; {&#10;      if (document.hidden) {&#10;        // Tab became hidden - pause the timer&#10;        setIsRunning(false);&#10;        stopTimer();&#10;      } else {&#10;        // Tab became visible - resume the timer if it should be running&#10;        if (shouldStart &amp;&amp; timeLeft &gt; 0) {&#10;          setIsRunning(true);&#10;          startTimer();&#10;        }&#10;      }&#10;    };&#10;&#10;    document.addEventListener('visibilitychange', handleVisibilityChange);&#10;&#10;    return () =&gt; {&#10;      document.removeEventListener('visibilitychange', handleVisibilityChange);&#10;    };&#10;  }, [timeLeft, startTimer, stopTimer, shouldStart]);&#10;&#10;  // Start timer when shouldStart becomes true&#10;  useEffect(() =&gt; {&#10;    if (shouldStart &amp;&amp; timeLeft &gt; 0) {&#10;      setIsRunning(true);&#10;      startTimer();&#10;    } else if (!shouldStart) {&#10;      setIsRunning(false);&#10;      stopTimer();&#10;    }&#10;&#10;    return () =&gt; stopTimer();&#10;  }, [shouldStart, timeLeft, startTimer, stopTimer]);&#10;&#10;  // Cleanup on unmount&#10;  useEffect(() =&gt; {&#10;    return () =&gt; stopTimer();&#10;  }, [stopTimer]);&#10;&#10;  const { minutes, seconds: secs } = formatTime(timeLeft);&#10;&#10;  return (&#10;    &lt;div className='flex items-center gap-2'&gt;&#10;      &lt;span className=' '&gt;&#10;        Времени осталось{' '}&#10;        &lt;b&gt;&#10;          {minutes} : {secs}&#10;        &lt;/b&gt;&#10;      &lt;/span&gt;&#10;    &lt;/div&gt;&#10;  );&#10;};&#10;&#10;export default Timer;&#10;" />
              <option name="updatedContent" value="'use client';&#10;import React, { useState, useEffect, useRef, useCallback } from 'react';&#10;&#10;interface TimerProps {&#10;  seconds: number;&#10;  setTimeHandler: (data: { total: number }) =&gt; void;&#10;  onTimerEndHandler: () =&gt; void;&#10;  shouldStart?: boolean; // New prop to control when timer starts&#10;}&#10;&#10;const Timer: React.FC&lt;TimerProps&gt; = ({ seconds, setTimeHandler, onTimerEndHandler, shouldStart = true }) =&gt; {&#10;  const [timeLeft, setTimeLeft] = useState(seconds);&#10;  const [, setIsRunning] = useState(false); // Start as false&#10;  const intervalRef = useRef&lt;NodeJS.Timeout | null&gt;(null);&#10;  const lastTickRef = useRef&lt;number&gt;(Date.now());&#10;&#10;  const formatTime = useCallback((milliseconds: number) =&gt; {&#10;    const totalSeconds = Math.floor(milliseconds / 1000);&#10;    const minutes = Math.floor(totalSeconds / 60);&#10;    const seconds = totalSeconds % 60;&#10;    return {&#10;      minutes: minutes &lt; 10 ? `0${minutes}` : minutes.toString(),&#10;      seconds: seconds &lt; 10 ? `0${seconds}` : seconds.toString(),&#10;    };&#10;  }, []);&#10;&#10;  const tick = useCallback(() =&gt; {&#10;    setTimeLeft((prev) =&gt; {&#10;      const newTime = Math.max(0, prev - 1000);&#10;      setTimeHandler({ total: newTime });&#10;      return newTime;&#10;    });&#10;  }, [setTimeHandler]);&#10;&#10;  useEffect(() =&gt; {&#10;    if (timeLeft === 0) {&#10;      onTimerEndHandler();&#10;    }&#10;  }, [timeLeft, onTimerEndHandler]);&#10;&#10;  const startTimer = useCallback(() =&gt; {&#10;    if (intervalRef.current) return;&#10;&#10;    intervalRef.current = setInterval(tick, 1000);&#10;    lastTickRef.current = Date.now();&#10;  }, [tick]);&#10;&#10;  const stopTimer = useCallback(() =&gt; {&#10;    if (intervalRef.current) {&#10;      clearInterval(intervalRef.current);&#10;      intervalRef.current = null;&#10;    }&#10;  }, []);&#10;&#10;  // Handle visibility change&#10;  useEffect(() =&gt; {&#10;    const handleVisibilityChange = () =&gt; {&#10;      if (document.hidden) {&#10;        // Tab became hidden - pause the timer&#10;        setIsRunning(false);&#10;        stopTimer();&#10;      } else {&#10;        // Tab became visible - resume the timer if it should be running&#10;        if (shouldStart &amp;&amp; timeLeft &gt; 0) {&#10;          setIsRunning(true);&#10;          startTimer();&#10;        }&#10;      }&#10;    };&#10;&#10;    document.addEventListener('visibilitychange', handleVisibilityChange);&#10;&#10;    return () =&gt; {&#10;      document.removeEventListener('visibilitychange', handleVisibilityChange);&#10;    };&#10;  }, [timeLeft, startTimer, stopTimer, shouldStart]);&#10;&#10;  // Start timer when shouldStart becomes true&#10;  useEffect(() =&gt; {&#10;    if (shouldStart &amp;&amp; timeLeft &gt; 0) {&#10;      setIsRunning(true);&#10;      startTimer();&#10;    } else if (!shouldStart) {&#10;      setIsRunning(false);&#10;      stopTimer();&#10;    }&#10;&#10;    return () =&gt; stopTimer();&#10;  }, [shouldStart, timeLeft, startTimer, stopTimer]);&#10;&#10;  // Cleanup on unmount&#10;  useEffect(() =&gt; {&#10;    return () =&gt; stopTimer();&#10;  }, [stopTimer]);&#10;&#10;  const { minutes, seconds: secs } = formatTime(timeLeft);&#10;&#10;  return (&#10;    &lt;div className='flex items-center gap-2'&gt;&#10;      &lt;span className=' '&gt;&#10;        Времени осталось{' '}&#10;        &lt;b&gt;&#10;          {minutes} : {secs}&#10;        &lt;/b&gt;&#10;      &lt;/span&gt;&#10;    &lt;/div&gt;&#10;  );&#10;};&#10;&#10;export default Timer;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/WordTable.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/WordTable.tsx" />
              <option name="originalContent" value="'use client';&#10;&#10;import React, { useState, useRef, useEffect } from 'react';&#10;import { IoIosArrowDown } from 'react-icons/io';&#10;import { motion, AnimatePresence } from 'framer-motion';&#10;&#10;interface WordTableProps {&#10;  usedWords: Set&lt;string&gt;;&#10;}&#10;&#10;const WordTable: React.FC&lt;WordTableProps&gt; = ({ usedWords }) =&gt; {&#10;  const [isExpanded, setIsExpanded] = useState(false);&#10;  const [visibleWords, setVisibleWords] = useState&lt;string[]&gt;([]);&#10;  const containerRef = useRef&lt;HTMLDivElement&gt;(null);&#10;&#10;  useEffect(() =&gt; {&#10;    const updateVisibleWords = () =&gt; {&#10;      const wordsArray = Array.from(usedWords);&#10;      setVisibleWords(wordsArray.reverse()); // Ensure new words appear on the left&#10;    };&#10;&#10;    updateVisibleWords();&#10;    window.addEventListener('resize', updateVisibleWords);&#10;    return () =&gt; window.removeEventListener('resize', updateVisibleWords);&#10;  }, [usedWords]);&#10;  // Track last animation direction&#10;  const [expandDirection, setExpandDirection] = useState&lt;'up' | 'down'&gt;('up');&#10;&#10;  // Update direction on expand/collapse&#10;  useEffect(() =&gt; {&#10;    setExpandDirection(isExpanded ? 'up' : 'down');&#10;  }, [isExpanded]);&#10;&#10;  const renderCollapsedView = () =&gt; {&#10;    // Move lengthGroups and limitedSortedLengths to the top of renderCollapsedView so they are in scope&#10;    const wordsArray = Array.from(usedWords);&#10;    const lengthGroups: Record&lt;number, string[]&gt; = {};&#10;    wordsArray.forEach((word) =&gt; {&#10;      const len = word.length;&#10;      if (!lengthGroups[len]) lengthGroups[len] = [];&#10;      lengthGroups[len].push(word);&#10;    });&#10;    const sortedLengths = Object.keys(lengthGroups)&#10;      .map(Number)&#10;      .sort((a, b) =&gt; a - b);&#10;    const maxDisplayedLengths = 6;&#10;    const limitedSortedLengths = sortedLengths.slice(0, maxDisplayedLengths);&#10;&#10;    return (&#10;      &lt;div&#10;        className={`relative w-full cursor-pointer rounded-lg border border-secondary bg-background px-4 py-2 transition-colors`}&#10;        onMouseDown={(e) =&gt; {&#10;          if (isExpanded || usedWords.size === 0) {&#10;            setIsExpanded(false);&#10;            e.stopPropagation();&#10;            return;&#10;          }&#10;          setIsExpanded(true);&#10;        }}&#10;        ref={containerRef}&#10;      &gt;&#10;        &lt;div className='flex items-center'&gt;&#10;          &lt;div className='relative flex-1 overflow-hidden'&gt;&#10;            {/* Blurred right edge overlay */}&#10;            &lt;AnimatePresence mode='wait'&gt;&#10;              {isExpanded &amp;&amp; usedWords.size !== 0 ? (&#10;                &lt;motion.div&#10;                  key='summary'&#10;                  initial={{ y: expandDirection === 'up' ? -10 : 10, opacity: 0 }}&#10;                  animate={{ y: 0, opacity: 1 }}&#10;                  exit={{ y: expandDirection === 'up' ? -10 : 10, opacity: 0 }}&#10;                  transition={{ duration: 0.1 }}&#10;                  className='flex gap-1'&#10;                &gt;&#10;                  &lt;span className='px-2 py-1 text-sm font-medium text-primary'&gt;&#10;                    Вы нашли {usedWords.size} {getWordDeclension(usedWords.size)}&#10;                  &lt;/span&gt;&#10;                &lt;/motion.div&gt;&#10;              ) : (&#10;                &lt;motion.div&#10;                  key='words'&#10;                  initial={{ y: expandDirection === 'up' ? -10 : 10, opacity: 0 }}&#10;                  animate={{ y: 0, opacity: 1 }}&#10;                  exit={{ y: expandDirection === 'up' ? -10 : 10, opacity: 0 }}&#10;                  transition={{ duration: 0.1 }}&#10;                  className='flex gap-1'&#10;                &gt;&#10;                  {usedWords.size === 0 ? (&#10;                    &lt;span className='px-2 py-1 text-sm text-secondary'&gt;Начните составлять слова...&lt;/span&gt;&#10;                  ) : (&#10;                    &lt;AnimatePresence initial={false}&gt;&#10;                      {visibleWords.map((word, index) =&gt; (&#10;                        &lt;motion.span&#10;                          key={index}&#10;                          initial={{ x: -40, opacity: 0 }}&#10;                          animate={{ x: 0, opacity: 1 }}&#10;                          exit={{ x: -40, opacity: 0 }}&#10;                          transition={{ duration: 0.1, ease: 'easeOut' }}&#10;                          className='flex-shrink-0 whitespace-nowrap rounded bg-background px-2 py-1 text-sm font-medium'&#10;                        &gt;&#10;                          {word.charAt(0).toUpperCase() + word.slice(1)}&#10;                        &lt;/motion.span&gt;&#10;                      ))}&#10;                    &lt;/AnimatePresence&gt;&#10;                  )}&#10;                &lt;/motion.div&gt;&#10;              )}&#10;            &lt;/AnimatePresence&gt;&#10;          &lt;/div&gt;&#10;          &lt;div className='ml-2'&gt;&#10;            &lt;IoIosArrowDown className={`text-secondary transition-transform duration-300 ${isExpanded ? 'rotate-180' : 'rotate-0'}`} /&gt;&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;        {/* Expanded view below collapsed view, not a separate box */}&#10;        &lt;AnimatePresence&gt;&#10;          {isExpanded &amp;&amp; (&#10;            &lt;motion.div&#10;              key='expanded'&#10;              initial={{ height: 0, opacity: 0 }}&#10;              animate={{ height: 'auto', opacity: 1 }}&#10;              exit={{ height: 0, opacity: 0 }}&#10;              transition={{ duration: 0.3 }}&#10;              className='overflow-hidden'&#10;            &gt;&#10;              &lt;div className='max-h-80 overflow-y-auto py-2'&gt;&#10;                &lt;div className='w-full'&gt;&#10;                  &lt;div className='flex w-full flex-wrap gap-2'&gt;&#10;                    {usedWords.size === 0 ? (&#10;                      &lt;p className='w-full text-center text-secondary'&gt;Пока слов не найдено&lt;/p&gt;&#10;                    ) : (&#10;                      limitedSortedLengths.map((len: number) =&gt; (&#10;                        &lt;div&#10;                          key={len}&#10;                          className=''&#10;                        &gt;&#10;                          &lt;div className='mb-2 whitespace-nowrap px-2 text-xs font-bold text-secondary'&gt;&#10;                            {len} {len === 4 ? 'буквы' : 'букв'}&#10;                          &lt;/div&gt;&#10;                          {lengthGroups[len].map((word: string, idx: number) =&gt; (&#10;                            &lt;div&#10;                              key={word + idx}&#10;                              className='rounded-lg bg-background px-2 transition-colors'&#10;                            &gt;&#10;                              &lt;span className='text-sm font-medium'&gt;{word.charAt(0).toUpperCase() + word.slice(1)}&lt;/span&gt;&#10;                            &lt;/div&gt;&#10;                          ))}&#10;                        &lt;/div&gt;&#10;                      ))&#10;                    )}&#10;                  &lt;/div&gt;&#10;                &lt;/div&gt;&#10;              &lt;/div&gt;&#10;            &lt;/motion.div&gt;&#10;          )}&#10;        &lt;/AnimatePresence&gt;&#10;      &lt;/div&gt;&#10;    );&#10;  };&#10;&#10;  // Close expanded view on outside click&#10;  useEffect(() =&gt; {&#10;    if (!isExpanded) return;&#10;    const handleClick = (e: MouseEvent) =&gt; {&#10;      if (containerRef.current &amp;&amp; !containerRef.current.contains(e.target as Node)) {&#10;        setIsExpanded(false);&#10;      }&#10;    };&#10;    document.addEventListener('mousedown', handleClick);&#10;    return () =&gt; document.removeEventListener('mousedown', handleClick);&#10;  }, [isExpanded]);&#10;&#10;  // Helper for Russian word declension&#10;  const getWordDeclension = (count: number) =&gt; {&#10;    const lastDigit = count % 10;&#10;    const lastTwoDigits = count % 100;&#10;    if (lastDigit === 1 &amp;&amp; lastTwoDigits !== 11) return 'слово';&#10;    if ([2, 3, 4].includes(lastDigit) &amp;&amp; ![12, 13, 14].includes(lastTwoDigits)) return 'слова';&#10;    return 'слов';&#10;  };&#10;&#10;  return &lt;div className='relative'&gt;{renderCollapsedView()}&lt;/div&gt;;&#10;};&#10;&#10;export default WordTable;&#10;" />
              <option name="updatedContent" value="'use client';&#10;&#10;import React, { useState, useRef, useEffect } from 'react';&#10;import { IoIosArrowDown } from 'react-icons/io';&#10;import { motion, AnimatePresence } from 'framer-motion';&#10;&#10;interface WordTableProps {&#10;  usedWords: Set&lt;string&gt;;&#10;}&#10;&#10;const WordTable: React.FC&lt;WordTableProps&gt; = ({ usedWords }) =&gt; {&#10;  const [isExpanded, setIsExpanded] = useState(false);&#10;  const [visibleWords, setVisibleWords] = useState&lt;string[]&gt;([]);&#10;  const containerRef = useRef&lt;HTMLDivElement&gt;(null);&#10;&#10;  useEffect(() =&gt; {&#10;    const updateVisibleWords = () =&gt; {&#10;      const wordsArray = Array.from(usedWords);&#10;      setVisibleWords(wordsArray.reverse()); // Ensure new words appear on the left&#10;    };&#10;&#10;    updateVisibleWords();&#10;    window.addEventListener('resize', updateVisibleWords);&#10;    return () =&gt; window.removeEventListener('resize', updateVisibleWords);&#10;  }, [usedWords]);&#10;  // Track last animation direction&#10;  const [expandDirection, setExpandDirection] = useState&lt;'up' | 'down'&gt;('up');&#10;&#10;  // Update direction on expand/collapse&#10;  useEffect(() =&gt; {&#10;    setExpandDirection(isExpanded ? 'up' : 'down');&#10;  }, [isExpanded]);&#10;&#10;  const renderCollapsedView = () =&gt; {&#10;    // Move lengthGroups and limitedSortedLengths to the top of renderCollapsedView so they are in scope&#10;    const wordsArray = Array.from(usedWords);&#10;    const lengthGroups: Record&lt;number, string[]&gt; = {};&#10;    wordsArray.forEach((word) =&gt; {&#10;      const len = word.length;&#10;      if (!lengthGroups[len]) lengthGroups[len] = [];&#10;      lengthGroups[len].push(word);&#10;    });&#10;    const sortedLengths = Object.keys(lengthGroups)&#10;      .map(Number)&#10;      .sort((a, b) =&gt; a - b);&#10;    const maxDisplayedLengths = 6;&#10;    const limitedSortedLengths = sortedLengths.slice(0, maxDisplayedLengths);&#10;&#10;    return (&#10;      &lt;div&#10;        className={`relative w-full cursor-pointer rounded-lg border border-secondary bg-background px-4 py-2 transition-colors`}&#10;        onMouseDown={(e) =&gt; {&#10;          if (isExpanded || usedWords.size === 0) {&#10;            setIsExpanded(false);&#10;            e.stopPropagation();&#10;            return;&#10;          }&#10;          setIsExpanded(true);&#10;        }}&#10;        ref={containerRef}&#10;      &gt;&#10;        &lt;div className='flex items-center'&gt;&#10;          &lt;div className='relative flex-1 overflow-hidden'&gt;&#10;            {/* Blurred right edge overlay */}&#10;            &lt;AnimatePresence mode='wait'&gt;&#10;              {isExpanded &amp;&amp; usedWords.size !== 0 ? (&#10;                &lt;motion.div&#10;                  key='summary'&#10;                  initial={{ y: expandDirection === 'up' ? -10 : 10, opacity: 0 }}&#10;                  animate={{ y: 0, opacity: 1 }}&#10;                  exit={{ y: expandDirection === 'up' ? -10 : 10, opacity: 0 }}&#10;                  transition={{ duration: 0.1 }}&#10;                  className='flex gap-1'&#10;                &gt;&#10;                  &lt;span className='px-2 py-1 text-sm font-medium text-primary'&gt;&#10;                    Вы нашли {usedWords.size} {getWordDeclension(usedWords.size)}&#10;                  &lt;/span&gt;&#10;                &lt;/motion.div&gt;&#10;              ) : (&#10;                &lt;motion.div&#10;                  key='words'&#10;                  initial={{ y: expandDirection === 'up' ? -10 : 10, opacity: 0 }}&#10;                  animate={{ y: 0, opacity: 1 }}&#10;                  exit={{ y: expandDirection === 'up' ? -10 : 10, opacity: 0 }}&#10;                  transition={{ duration: 0.1 }}&#10;                  className='flex gap-1'&#10;                &gt;&#10;                  {usedWords.size === 0 ? (&#10;                    &lt;span className='px-2 py-1 text-sm text-secondary'&gt;Начните составлять слова...&lt;/span&gt;&#10;                  ) : (&#10;                    &lt;AnimatePresence initial={false}&gt;&#10;                      {visibleWords.map((word, index) =&gt; (&#10;                        &lt;motion.span&#10;                          key={index}&#10;                          initial={{ x: -40, opacity: 0 }}&#10;                          animate={{ x: 0, opacity: 1 }}&#10;                          exit={{ x: -40, opacity: 0 }}&#10;                          transition={{ duration: 0.1, ease: 'easeOut' }}&#10;                          className='flex-shrink-0 whitespace-nowrap rounded bg-background px-2 py-1 text-sm font-medium'&#10;                        &gt;&#10;                          {word.charAt(0).toUpperCase() + word.slice(1)}&#10;                        &lt;/motion.span&gt;&#10;                      ))}&#10;                    &lt;/AnimatePresence&gt;&#10;                  )}&#10;                &lt;/motion.div&gt;&#10;              )}&#10;            &lt;/AnimatePresence&gt;&#10;          &lt;/div&gt;&#10;          &lt;div className='ml-2'&gt;&#10;            &lt;IoIosArrowDown className={`text-secondary transition-transform duration-300 ${isExpanded ? 'rotate-180' : 'rotate-0'}`} /&gt;&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;        {/* Expanded view below collapsed view, not a separate box */}&#10;        &lt;AnimatePresence&gt;&#10;          {isExpanded &amp;&amp; (&#10;            &lt;motion.div&#10;              key='expanded'&#10;              initial={{ height: 0, opacity: 0 }}&#10;              animate={{ height: 'auto', opacity: 1 }}&#10;              exit={{ height: 0, opacity: 0 }}&#10;              transition={{ duration: 0.3 }}&#10;              className='overflow-hidden'&#10;            &gt;&#10;              &lt;div className='max-h-80 overflow-y-auto py-2'&gt;&#10;                &lt;div className='w-full'&gt;&#10;                  &lt;div className='flex w-full flex-wrap gap-2'&gt;&#10;                    {usedWords.size === 0 ? (&#10;                      &lt;p className='w-full text-center text-secondary'&gt;Пока слов не найдено&lt;/p&gt;&#10;                    ) : (&#10;                      limitedSortedLengths.map((len: number) =&gt; (&#10;                        &lt;div&#10;                          key={len}&#10;                          className=''&#10;                        &gt;&#10;                          &lt;div className='mb-2 whitespace-nowrap px-2 text-xs font-bold text-secondary'&gt;&#10;                            {len} {len === 4 ? 'буквы' : 'букв'}&#10;                          &lt;/div&gt;&#10;                          {lengthGroups[len].map((word: string, idx: number) =&gt; (&#10;                            &lt;div&#10;                              key={word + idx}&#10;                              className='rounded-lg bg-background px-2 transition-colors'&#10;                            &gt;&#10;                              &lt;span className='text-sm font-medium'&gt;{word.charAt(0).toUpperCase() + word.slice(1)}&lt;/span&gt;&#10;                            &lt;/div&gt;&#10;                          ))}&#10;                        &lt;/div&gt;&#10;                      ))&#10;                    )}&#10;                  &lt;/div&gt;&#10;                &lt;/div&gt;&#10;              &lt;/div&gt;&#10;            &lt;/motion.div&gt;&#10;          )}&#10;        &lt;/AnimatePresence&gt;&#10;      &lt;/div&gt;&#10;    );&#10;  };&#10;&#10;  // Close expanded view on outside click&#10;  useEffect(() =&gt; {&#10;    if (!isExpanded) return;&#10;    const handleClick = (e: MouseEvent) =&gt; {&#10;      if (containerRef.current &amp;&amp; !containerRef.current.contains(e.target as Node)) {&#10;        setIsExpanded(false);&#10;      }&#10;    };&#10;    document.addEventListener('mousedown', handleClick);&#10;    return () =&gt; document.removeEventListener('mousedown', handleClick);&#10;  }, [isExpanded]);&#10;&#10;  // Helper for Russian word declension&#10;  const getWordDeclension = (count: number) =&gt; {&#10;    const lastDigit = count % 10;&#10;    const lastTwoDigits = count % 100;&#10;    if (lastDigit === 1 &amp;&amp; lastTwoDigits !== 11) return 'слово';&#10;    if ([2, 3, 4].includes(lastDigit) &amp;&amp; ![12, 13, 14].includes(lastTwoDigits)) return 'слова';&#10;    return 'слов';&#10;  };&#10;&#10;  return &lt;div className='relative'&gt;{renderCollapsedView()}&lt;/div&gt;;&#10;};&#10;&#10;export default WordTable;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>